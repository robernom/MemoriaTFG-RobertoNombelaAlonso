%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish,es-tabla]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{enumerate}
\usepackage{listings}
\usepackage{dirtree}
\usepackage{multirow}

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
INGENIERÍA EN SISTEMAS AUDIOVISUALES Y MULTIMEDIA

\vspace{0.4cm}

\large
Curso Académico 2017/2018

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
EVALUACIÓN DE PROYECTOS APPINVENTOR
\vspace{4cm}

\large
Autor : Roberto Nombela Alonso \\
Tutor : Dr. Gregorio Robles
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Evaluación de Proyectos AppInventor 

\vspace{1cm}
\large
\textbf{Autor :} Roberto Nombela Alonso \\
\textbf{Tutor :} Dr. Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2018, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2018
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia y, en especial, a Sofía. \\
Sin ella no habría llegado hasta aquí.}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

En primer lugar quiero dar las gracias a mi familia. Que siempre ha estado tan pendiente de mí, apoyándome en todo momento, consolándome tras cada fallo y alegrándose de mis logros. Saber que puedo contar con vosotros cuando lo necesite me ha dado (y me da) fuerzas.\\

Por otro lado, agradecer a Ahmed, Álvaro y Ángel, mis compañeros de batalla. Por las tardes y noches de Skype, las prácticas interminables y los ejercicios irresolubles, pero siempre con buen humor. Si sobrevivo a esta carrera es gracias a vosotros.\\

Gracias a todos mis compañeros y amigos, no quiero decir nombres porque me dejaría a alguien y no sería justo. A los que se preocuparon por cómo me iba y me animaron a seguir, a los que tuvieron buenas palabras en momentos malos. En definitiva, a los que han estado.\\

Agradecer a Gregorio la oportunidad única que me ha brindado con la Beca de Colaboración y toda la ayuda que me ha proporcionado.\\

Por último pero no por ello menos importante, quiero dar las gracias a Sofía. Por todo. Desde que se vino a Madrid no he vuelto a repetir ninguna asignatura. Las casualidades no existen.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Este Trabajo Fin de Grado consiste en una evaluación de proyectos del entorno AppInventor, cuyo código se compone de bloques. Durante el proceso, se analizan los distintos bloques que se emplean en los programas con el fin de obtener una visión general de lo que están desarrollando actualmente los usuarios de AppInventor. 

Esta idea surge a partir de las herramientas que evalúan el pensamiento computacional en los proyectos, como Dr. Scratch o Code Master. Dichas herramientas son de utilidad para dar una puntuación pero no proporcionan suficiente \emph{feedback} para que el usuario mejore. Por ello, el objetivo final es encontrar caminos de mejora de las habilidades del pensamiento computacional.

Para conseguirlo, se desarrolla la herramienta Dr. AppInventor, una aplicación web basada en Dr. Scratch para el análisis de proyectos AppInventor. La aplicación está escrita en Django, un framework para aplicaciones web de Python. Después, modificando el algoritmo de Dr. AppInventor, se extraen los bloques y las puntuaciones de un conjunto de proyectos, previamente extraídos de la galería, y se procede al análisis de los datos conseguidos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

This Thesis consists of an assessment of projects in the AppInventor environment, which code is composed of blocks. During the process, the different blocks used in the programs are analyzed in order to get an overview of what AppInventor users are currently developing.

This idea arises from tools that evaluate computational thinking in projects, such as Dr. Scratch or Code Master. These tools are useful for giving a score but do not provide enough feedback for the user to improve. Therefore, the goal is to find ways to improve computational thinking skills.

To achieve this, we developed the Dr. AppInventor tool, a Dr. Scratch-based web application for the analysis of AppInventor projects. The application is written in Django, a Python web applications framework. Then, modifying the Dr. AppInventor algorithm, the blocks and scores of a set of projects, previously extracted from the gallery, are extracted and the data obtained are analyzed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{chap:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Este Trabajo Fin de Grado tiene como objetivo el desarrollo de una herramienta que facilite el análisis de proyectos creados con MIT AppInventor\footnote{\url{http://ai2.appinventor.mit.edu/}}. La herramienta, llamada Dr. AppInventor, extrae y clasifica los bloques de cada proyecto y devuelve una puntuación en función de unos criterios que evalúan el desarrollo de Pensamiento Computacional, término sobre el que se cimienta este trabajo.

\section{Contexto}
\label{sec:context}

En el año 2006, J. Wing presentó el concepto del Pensamiento Computacional~\cite{wing2006computational}
como un proceso de razonamiento que permite formular y resolver problemas de cualquier ámbito.
Esto quiere decir que el Pensamiento Computacional no se restringe a las matemáticas o a la programación, sino que cualquier persona puede beneficiarse de pensar como un informático. El Pensamiento Computacional consta de una serie de aptitudes que permiten abarcar un problema: abstracción, pensamiento paralelo, pensamiento algorítmico, representación de datos.

Una manera de desarrollar dichas aptitudes es mediante la programación, que fomenta la creatividad y el uso de la lógica~\cite{resnick2009scratch}. Programar implica plasmar pensamientos en forma de código y representar externamente el proceso de resolución de un problema.
Los lenguajes de programación visual basados en bloques se caracterizan por ser realmente intuitivos, lo que los hace perfectos candidatos para mejorar las habilidades de las personas que no están del todo familiarizadas con la programación.

Consecuentemente, han aparecido herramientas que evalúan el desarrollo de Pensamiento Computacional de los aprendices a partir de los proyectos que han creado usando estos lenguajes y entornos de programación. Su objetivo es indicar los puntos fuertes y carencias del aprendiza para que pueda autoevaluarse y seguir aprendiendo. En la sección~\ref{sec:dr-ai} se darán detalles de cómo evalúan. Estas herramientas han comenzado a utilizarse en centros educativos, de modo que profesores y alumnos pueden beneficiarse de la evaluación que ofrecen.

\section{Motivación}
\label{sec:motiv}

Estudios recientes han descubierto que las herramientas de análisis han resultado ser más útiles para los profesores a la hora de corregir, que para los alumnos a la hora de mejorar~\cite{robles2018ontools}.
No obstante, si queremos que dichas herramientas cumplan con una función más didáctica, hemos de dedicar mayor atención al proceso de aprendizaje. Por ello realizamos Dr. AppInventor, para tener una herramienta que permite la evaluación de proyectos AppInventor de manera automática. Con Dr. AppInventor hemos realizado un análisis de un gran número de proyectos para obtener una visión general de los proyectos que está desarrollando la comunidad. Con esta visión queremos encontrar posibles formas de ayudar al alumno a mejorar sus habilidades, ya sea mediante lecciones, consejos o ejemplos, con la idea de introducirlas en la herramienta. 

\subsection*{Motivación Personal}
\label{subsec:pers-motiv}

Desde un punto de vista personal, hay tres elementos clave que han hecho que me decantara por este proyecto: 
\begin{itemize}
\item Ayudar a otras personas a aprender: siempre me ha gustado compartir lo que sé con compañeros y amigos que lo han necesitado, buscando la mejor manera de explicarme para que lo comprendieran.
\item Crear una aplicación web: por las comodidades que ofrece, en cuanto a compatibilidad, respecto a las aplicaciones de escritorio. 
\item Realizar un análisis de datos: la Ciencia de Datos es un campo en crecimiento y ya tenía interés en introducirme. Ha sido la excusa perfecta.
\end{itemize}

\section{Estructura de la memoria}
\label{sec:estructura}

En esta sección se detalla la estructura de la memoria, la cual está dividida en 6 capítulos. Cada uno de estos capítulos se explica a continuación:

\begin{itemize}
  \item El capítulo~\ref{chap:intro} es una Introducción al proyecto, donde se da a conocer el contexto en el que se enmarca, se explica la motivación por la cual se ha llevado a cabo y se muestra la estructura que sigue.
  
  \item En el capítulo~\ref{chap:objetivos} se muestra el objetivo principal del proyecto, junto con los subobjetivos necesarios para cumplirlo. Cada subobjetivo muestra el periodo de tiempo durante el que se realizó.
  
  \item Estado del arte: en este capítulo se exponen con una breve explicación las tecnologías existentes que se han utilizado para la realización del trabajo. Estas tecnologías son: AppInventor, Dr. Scratch, Python, Django y pandas.
  
  \item Diseño e implementación: este capítulo explica detalladamente la creación de la herramienta Dr. AppInventor y la preparación del algoritmo para extraer los datos de los proyectos.
  
  \item El capítulo~\ref{chap:results} muestra los resultados obtenidos tras analizar los datos extraídos en el capítulo anterior. Proporciona información sobre el número de bloques, la variedad, los tipos de bloques más y menos utilizados
  
  \item Conclusiones: aquí se detalla la consecución de los objetivos y los problemas que se han presentado durante la realización del trabajo. También se habla de los conocimientos previos aplicados, de los conocimientos que se han adquirido y de los posibles trabajos futuros.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)
 
El objetivo principal de este proyecto es crear una herramienta que evalúe el desarrollo de Pensamiento Computacional de proyectos de MIT AppInventor. De esta manera se pueden buscar caminos de aprendizaje que permitan a los alumnos (o cualquier persona interesada en aprender) mejorar sus habilidades de pensamiento computacional utilizando AppInventor. Para ello, vamos a analizar los proyectos de la comunidad AppInventor, con el que obtendremos una visión general de los proyectos que se están desarrollando.

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

En el proceso de alcanzar el objetivo general, ha sido necesario realizar antes unas tareas u objetivos específicos que se exponen a continuación, junto con el periodo de tiempo en el que se llevaron a cabo:

\begin{enumerate}[1.]

\item Finales de septiembre de 2017 - Octubre de 2017. Documentación sobre el contexto en el que se desarrolla el trabajo: pensamiento computacional, lenguajes de programación visual basados en bloques y herramientas de análisis de programas en dichos lenguajes.

\item Octubre de 2017 - Noviembre de 2017. Conocer la estructura de AppInventor: uso y funcionamiento, los tipos de bloques y componentes que pueden emplearse en los proyectos y los ficheros que forman un proyecto.
	
\item Noviembre de 2017 - Febrero de 2018. Estudiar la aplicación de Dr. Scratch\footnote{\url{http://drscratch.org/}}, que evalúa proyectos Scratch, para crear una adaptación que permita evaluar proyectos AppInventor. El desarrollo de Dr. AppInventor se explicará con detalle en el capítulo~\ref{chap:design}.

\item Febrero de 2018. Adaptar el algoritmo de Dr. AppInventor para extraer bloques y evaluar varios proyectos, guardando esta información en ficheros CSV.

\item Finales de febrero de 2018 - Marzo de 2018. Obtener de la galería de AppInventor una gran cantidad de proyectos.

\item Marzo de 2018 - Abril de 2018. Analizar los CSV obtenidos con Dr. AppInventor utilizando la librería pandas en un Jupyter Notebook.
\end{enumerate}

% Unidos los objetivos específicos con la planificación temporal

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:art}

En este apartado se describen las diferentes tecnologías que se han utilizado para llevar a cabo este proyecto.

\section{AppInventor}
\label{sec:ai}

AppInventor~\cite{wolber2011app} es un entorno de programación visual que permite crear aplicaciones móviles para Android. Surge para ayudar a las personas a pasar del consumo de tecnología a la creación. El ``código" que utiliza son bloques que los usuarios pueden arrastrar y soltar, para unirlos entre sí como si fuera un \emph{puzzle}.

Este entorno utiliza dos modos para la creación de una aplicación: \emph{Blocks} y \emph{Designer}. En las figuras~\ref{figura:ai-blocks} y~\ref{figura:ai-designer}\footnote{Fuente: \url{http://explore.appinventor.mit.edu/designer-blocks}}, se muestran las pantallas de ambos modos con los diferentes elementos que los conforman.

\textbf{Blocks}: en este modo se define el comportamiento de la aplicación, es decir, se implementa el algoritmo. Hay 8 tipos diferentes de bloques: Control, Logic, Math, Text, Lists, Colors, Variables y Procedures. Además, se pueden ver bloques específicos de componentes. Estos componentes deben haberse seleccionado previamente en el modo Designer. El aspecto visual del modo ``blocks'' se puede encontrar en la figura~\ref{figura:ai-blocks}.

  \begin{figure}
    \centering
    \includegraphics[bb=0 0 800 600, width=12cm, keepaspectratio]{img/ai-blocks}
    \caption{Elementos del modo Blocks.}
    \label{figura:ai-blocks}
 \end{figure}
 
\textbf{Designer}: en este modo se seleccionan los componentes que van a constituir la aplicación. Estos componentes pueden ser visuales (los que formarán la interfaz de usuario) o no visuales (diversas funcionalidades del dispositivo como el acelerómetro o Bluetooth, bases de datos o comandos que permiten controlar robots LEGO® MINDSTORMS® NXT). Se puede ver un ejemplo del modo ``designer'' en la Figura~\ref{figura:ai-designer}.
 
  \begin{figure}
    \centering
    \includegraphics[bb=0 0 800 600, width=12cm, keepaspectratio]{img/ai-designer}
    \caption{Elementos del modo Designers.}
    \label{figura:ai-designer}
 \end{figure}

%Con dos o tres párrafos por cada tecnología, vale. 

\section{Python} 
\label{sec:python}

Python en un lenguaje de programación interpretado, interactivo y orientado a objetos~\cite{kuhlman2011python}. Su creador, Guido van Rossum, explicó que Python surgió como un ``hobby'' para mantenerse ocupado durante las Navidades de 1989, basándose en el lenguaje ABC, con el pensamiento de que esto atraería a los programadores de Unix/C~\cite{lutz2010programming}. 

Entre sus características destacan el gran número de módulos que posee, la posibilidad de incluir código C o C++ para aumentar la velocidad, la portabilidad (Windows, Mac y algunas variantes de Unix) pero, sobre todo, destaca por su filosofía:

Esta filosofía, conocida como ``El Zen de Python'', fue escrita por Tim Peters. Forma parte de las Propuestas de Mejoras de Python (PEP 20\footnote{\url{https://www.python.org/dev/peps/pep-0020/}}) y aboga por que el código sea:
\begin{itemize}
 \item Simple: ``Simple is better than complex''.
 \item Legible: ``Readability counts''.
 \item Claro: ``If the implementation is hard to explain, it's a bad idea''.
\end{itemize}

\section{Django}
\label{sec:django}

Django\footnote{\url{https://www.djangoproject.com/}} es un framework para aplicaciones web, escrito en Python. Permite un desarrollo rápido, con un diseño limpio y práctico gracias a su filosofía DRY (Don't Repeat Yourself). Debido a esto, destaca por tener un número reducido de ficheros y carpetas. En la Tabla~\ref{tabla:comp-django}, se observa una comparación con otros framework~\cite{bastida2012django}.

\begin{table}[H]
 \begin{center}
 \begin{tabular}{ | l | r | r | r |} 
    \hline
   & Rails & Symfony & \textbf{Django} \\ \hline
   Ficheros & 149 & 117 & \textbf{5} \\ \hline
   Carpetas & 35 & 29 & \textbf{2} \\
   \hline
 \end{tabular}
 \caption{Ficheros y carpetas en Django vs. otros frameworks.}
 \label{tabla:comp-django}
 \end{center}
\end{table}

Se basa en el patrón MVC (Modelo-Vista-Controlador). El modelo se define en models.py y contiene la información de los datos que maneja el servidor. El controlador está formado por dos scripts: urls.py que, dependiendo de la petición HTTP, invoca a una vista o a otra y views.py que genera la respuesta HTTP, consultando al modelo si es necesario. La vista es la respuesta generada por el controlador, comúnmente es el HTML de una página web.

Otras ventajas que presenta Django son el ORM y el lenguaje de plantillas:

\begin{itemize}
  \item ORM (Object-Relational Mapping): realiza un mapeo de diferentes bases de datos, de modo que el usuario no necesita conocer los comandos de SQLite o MySQL, ya que puede manejar las bases de datos empleando código de Python.

  \item Lenguaje de plantillas: permite introducir variables y lógica simple en un HTML del siguiente modo: \{\{ variable \}\}, \{\% código \%\}. Para el uso de variables, en el render se pasa como argumento el contexto: un diccionario clave-valor, donde la clave es el nombre que va a tomar la variable dentro de la plantilla y el valor es la variable en sí.
\end{itemize}

\begin{figure}[htbp]
  \centering
  \includegraphics[bb=0 0 800 600, width=12cm, keepaspectratio]{img/django-mvc}
  \caption{Estructura MVC de Django.}
  \label{figura:mvc}
\end{figure}

\section{HTML}

HTML (HyperText Markup Language)~\cite{w3c2018html}, es el lenguaje principal de marcado de la web. Inicialmente fue planteado para describir semánticamente documentos científicos. Actualmente, debido a su diseño, se ha adaptado para describir otros tipos de documentos e incluso aplicaciones. El uso más conocido de HTML es la creación y representación visual de páginas web. Este lenguaje define la estructura de una página, pero no su funcionalidad. 

Los documentos HTML tienen estructuras de árbol de elementos y texto. Cada elemento se denota en el código con etiquetas de inicio, junto con las que encontramos los atributos, y etiquetas de fin. El contenido se encuentra entre las dos etiquetas. Un ejemplo sería:

$<$etiqueta atributo=``valor''$>$ contenido $<$\/etiqueta$>$.

Se complementa con otras tecnologías para modificar la apariencia de la página (CSS) o para determinar la funcionalidad (JavaScript).

\section{CSS}

CSS (Cascade Style Sheets)~\cite{css}, son las siglas de hojas de estilo en cascada. Es el lenguaje que describe la presentación de una página web: colores, diseño y fuentes. Permite adaptar la presentación a distintos dispositivos, como pantallas de ordenador, móviles o tablets. Se puede utilizar con cualquier lenguaje de marcado basado en XML pero sobre todo se utiliza junto con HTML.

Para dar estilo, se referencia el elemento deseado y se incluyen los atributos, por ejemplo: \\
elemento \{

color: ``color''; \\
\}



\section{JavaScript}

Es un lenguaje de programación desarrollado por Netscape que, originalmente, se llamó LiveScript. En 1995, como Java estaba en crecimiento, por razones de marketing comenzó a llamarse JavaScript, aunque los lenguajes no están relacionados entre sí~\cite{flanagan2006javascript}.

JavaScript es interpretado, basado en prototipos, dinámico y débilmente tipado. Está compuesto de sentencias, comandos que ejecutará el navegador, separadas con punto y coma (;).  Se caracteriza por ser el lenguaje del lado cliente en las aplicaciones web y se suele utilizar para: interacción con el navegador o con el documento HTML, para abrir conexiones con el servidor (AJAX) o para dibujar en la página (canvas).

\section{jQuery}

jQuery es una librería de JavaScript rápida, ligera y rica en funciones con la idea de escribir menos y hacer más. El propósito es facilitar el uso de JavaScript en los sitios web. Para ello, jQuery utiliza métodos de una sola línea que realizan tareas que con JavaScript ocuparían varias. También simplifica muchas de las funcionalidades que son más complicadas con JavaScript, como las llamadas AJAX o la manipulación de los elementos de un HTML.

Entre sus prestaciones destacamos: manipulación de HTML o CSS; manejo de eventos; desarrollo de animaciones; interacción con AJAX.

La Tabla~\ref{tabla:comp-code} muestra la reducción que proporciona jQuery respecto a JavaScript:

\begin{table}[H]
 \begin{center}
 \begin{tabular}{ | c | c | } 
    \hline
   \textbf{JavaScript} & \textbf{jQuery} \\ \hline
   function changeBackgroundColor(color)\{ & \\
   document.body.style.background = color;\} & \$ (`body').css(`background', `\#ccc')  \\ 
   onload = ``changeBackgroundColor(`red');'' & \\
   \hline
 \end{tabular}
 \caption{Comparación de los códigos JS y jQuery.}
 \label{tabla:comp-code}
 \end{center}
\end{table}

\section{Dr. Scratch} 
\label{sec:drscratch}

Antes de empezar a implementar la aplicación web Dr. AppInventor, fue precisa una comprensión de lo que se pretendía desarrollar. Esta aplicación está basada en Dr. Scratch\footnote{\url{http://www.drscratch.org/}} que realiza una evaluación del pensamiento computacional en proyectos Scratch\footnote{\url{https://scratch.mit.edu/}}. Dr. Scratch obtiene una puntuación en función de los siguientes aspectos: abstracción, pensamiento lógico, sincronización, paralelismo, control de flujo, interactividad con el usuario y representación de la información. Cada uno se valora del 0 al 3 y la suma de todos es la puntuación final~\cite{moreno2015dr}. Además de la puntuación, ofrece al usuario \emph{feedback} para mejorar dichos aspectos y, dependiendo de la puntuación, resalta malos hábitos de programación como puede ser código repetido o código que nunca se llega a ejecutar. Los usuarios tienen la opción también de descargar un diploma con los resultados de su proyecto. En la Figura~\ref{figura:dr-scratch} se puede ver un ejemplo de análisis de un proyecto.

\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/dr-scratch}
  \caption{Análisis de un proyecto en Dr. Scratch.}
  \label{figura:dr-scratch}
\end{figure}


\section{pandas}

Es una librería de código abierto nacida en 2008~\cite{python2008pandas}. Proporciona estructuras de datos de alto rendimiento y fáciles de usar, además de herramientas de análisis de datos. Su objetivo es ser el componente fundamental de alto nivel para realizar análisis de datos prácticos y reales en Python.

Algunos de los elementos que forman pandas son:

\begin{itemize}

\item Estructuras de datos etiquetadas: Series (matriz unidimensional capaz de contener cualquier tipo de datos) y DataFrame (estructura bidimensional, puede verse como un conjunto de Series). Los DataFrames son los más comúnmente utilizados en pandas.

\item Objetos que permiten tanto la indexación de ejes simples como la indexación de ejes jerárquicos/multiniveles.

\item Herramientas para agregar y transformar conjuntos de datos.

\item Herramientas de entrada/salida: carga de tablas desde archivos planos (CSV, delimitados, Excel 2003), y almacenamiento y carga de objetos pandas desde el formato PyTables/HDF5.

\item Combinación con otros paquetes como NumPy (computación científica) y matplotlib (representación de gráficos).

\end{itemize}

\section{Jupyter Notebooks}

Junto con pandas, se suele utilizar Jupyter Notebook\footnote{\url{http://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html}}. Este ``cuaderno'' es una aplicación web que ofrece una interfaz al proceso de programación: desarrollo, documentación y ejecución, además permite visualizar los resultados cómodamente~\cite{jupyter}. A continuación, se muestran algunas características de la aplicación:

\begin{itemize}

\item Edición del código en el navegador, con resaltado de sintaxis, indentación y completación de tabulaciones.

\item Posibilidad de ejecutar código desde el navegador y mostrar los resultados de los cálculos bajo el código ejecutado.

\item Visualización de resultados utilizando representaciones multimedia, como HTML, LaTeX, PNG, SVG, etc. Por ejemplo, las figuras renderizadas con la librería matplotlib.

\item Capacidad de incluir fácilmente notación matemática utilizando LaTeX, renderizado de forma nativa por MathJax.

\end{itemize}

La Figura~\ref{figura:pandas} es un ejemplo de instrucciones de pandas en un Jupyter Notebook.

\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/pandas}
  \caption{Código pandas en Jupyter Notebook.}
  \label{figura:pandas}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{chap:design}

En este capítulo se explican los pasos necesarios para poder llevar a cabo el proyecto, que ya se mencionaron brevemente en la sección~\ref{sec:objetivos-especificos}. La Figura~\ref{figura:diag} representa un diagrama de bloques con los hitos seguidos.

\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/diag}
  \caption{Diagrama de bloques del proyecto.}
  \label{figura:diag}
\end{figure}

\begin{itemize}
  \item AppInventor/Dr. Scratch: Antes de comenzar a implementar Dr. AppInventor, un paso previo fue la familiarización con Dr. Scratch y AppInventor. Estas dos tecnologías fueron explicadas en el capítulo~\ref{chap:art}. A diferencia de Dr. Scratch, en el caso de Dr. AppInventor únicamente se realiza la evaluación de los proyectos ya que el análisis se centra en el pensamiento computacional. No se proporciona \emph{feedback} para cada uno de los criterios ni tampoco se informa de las malas prácticas.
  
  \item Dr. AppInventor como aplicación web: la implementación de la aplicación desde la extracción de bloques y componentes hasta la evaluación de los proyectos. La implementación se explica con detalle en la sección~\ref{sec:dr-ai}.
  
  \item Recopilación de proyectos: qué proyectos se han utilizado para el análisis y cómo se han conseguido.  
  
  \item Dr. AppInventor para múltiples proyectos: modificar el algoritmo de Dr. AppInventor para analizar los proyectos obtenidos. La sección~\ref{sec:dr-ai-multi} detalla esta modificación.
  
  \item Análisis de los resultados: se realiza un estudio de los bloques con los datos proporcionados por el algoritmo. En el capítulo~\ref{chap:results} se desarrolla este análisis.  
  

\end{itemize}


\section{Dr. AppInventor como aplicación web}
\label{sec:dr-ai}

Una vez conocido el funcionamiento de Dr. Scratch y de AppInventor (sección~\ref{sec:ai}), se comienza con el proyecto en Django que dará lugar a la aplicación web.

\subsection{Extracción de bloques y componentes}
\label{subsec:extract}

El algoritmo comienza con la extracción de las carpetas y ficheros que forman un programa en AppInventor, para ello hay que descomprimir el archivo del programa como si fuera un ZIP. A continuación se puede ver en forma de árbol la estructura de los directorios obtenidos: 

\dirtree{%
.1 project.
.2 assets.
.3 MultimediaFiles.
.2 src.
.3 appinventor.
.4 ai\_UserName.
.5 ProjectName.
.6 Screen1.bky.
.6 Screen1.scm.
.6 \dots .
.6 ScreenN.bky.
.6 ScreenN.scm.
.2 youngandroidproject.
.3 project.properties.
}

La carpeta \emph{assets} contiene los archivos multimedia (imágenes, audios y vídeos) que utiliza la aplicación. 

La carpeta \emph{youngandroidproject} contiene el fichero con las propiedades de la aplicación, como por ejemplo: el nombre del proyecto en AppInventor, el nombre de la app o la versión. 

La carpeta de verdadero interés para el análisis es \emph{src}, dentro de la cual están los ficheros .bky y .scm, cada una de las pantallas de la aplicación está formada por estos dos ficheros, cuyo nombre coincide con el nombre de la pantalla:
\begin{itemize}
  \item \textbf{bky}: este fichero contiene, en forma de XML, los bloques que componen el programa, sus propiedades y cómo se relacionan entre sí. Para extraer los bloques, el algoritmo tendrá que buscar todas las etiquetas \emph{block} y almacenar de cada una el atributo \emph{type}. Podemos ver un ejemplo de este tipo de fichero en la Figura~\ref{figura:bky}. En este ejemplo, el primer bloque que se almacenaría lo vemos en la segunda línea: component\_event.
  
\begin{figure}[!h]
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/bky}
  \caption{Contenido de un fichero .bky.}
  \label{figura:bky}
\end{figure}
  
  \item \textbf{scm}: de manera similar al fichero .bky, aquí encontramos, con estructura JSON, los componentes y sus propiedades. Para extraer los componentes, el algoritmo busca todos los elementos con clave \emph{\$Name} y almacena su valor, excepto del primer elemento ya que no es un componente en sí, sino que representa los ajustes (``Settings") de la aplicación. La Figura~\ref{figura:scm} es un ejemplo de este tipo de fichero. El primer componente en el ejemplo se encuentra en la línea 5: HorizontalArrangement1.  
  
\begin{figure}[!h]
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/scmcut}
  \caption{Contenido de un fichero .scm.}
  \label{figura:scm}
\end{figure}
\end{itemize}

\subsection{Puntuación del proyecto}
\label{sec:score}
Teniendo extraídos todos los bloques y componentes, comienza la fase de clasificación. Para clasificar (y, posteriormente, puntuar) nos basamos en la rúbrica de Code Master\footnote{\url{http://apps.computacaonaescola.ufsc.br:8080/rubrica_appinventor.jsp}}, una herramienta que analiza proyectos Snap! y AppInventor. Los criterios para obtener la puntuación son los siguientes: 

\textbf{Screens}: hay que tener en cuenta tres cosas: el número de pantallas, si las pantallas contienen componentes visuales o no y si las pantallas cambian de estado programáticamente. Para obtener el número de pantallas, contamos el número de ficheros .bky (también se podrían contar los .scm y obtendríamos el mismo resultado). Si queremos ver si una pantalla contiene componentes visuales, tenemos que comprobar si alguno de sus componentes están en la lista de visuales. Por último, si la pantalla contiene cualquier bloque se puede decir que, potencialmente, cambiará de estado.

\textbf{User Interface}: la puntuación de este criterio depende del número de componentes visuales en la aplicación y también de las disposiciones (arrangements). Contamos los componentes visuales comparándolos con la lista mencionada en el punto anterior. Las disposiciones son un componente más en la aplicación, pueden llamarse: HorizontalArrangement, Horizontal-ScrollArrangement, VerticalArrangement, VerticalScrollArrangement y TableArrangement. Por lo que para contarlas con el algoritmo, buscamos cualquier componente cuyo tipo contenga Arrangement en su nombre.

\textbf{Naming}: este criterio evalúa si el nombre de una variable, componente o procedimiento se ha cambiado o, por el contrario, se ha dejado el nombre por defecto. En el caso de las variables y los procedimientos, los nombres serían: name/procedure, name2/procedure2, \dots Mientras que el nombre por defecto de los componentes depende del tipo, por ejemplo, si el tipo es Ball: Ball1, Ball2, etc. La puntuación dependerá del porcentaje total de nombres por defecto.

\textbf{Events}: la puntuación de los eventos depende del número de manejadores que se empleen. Para contabilizarlos con el algoritmo, hay que localizar todos los bloques del tipo component\_event.

\textbf{Procedural Abstraction}: en este criterio se comprueba el uso de procedimientos (procedures). Hay dos maneras de crear procedimientos: procedures\_defreturn y procedures\_defnoreturn. La máxima puntuación se da cuando hay más llamadas a procedimientos que procedimientos. Esto lo comprobamos comparando el número de bloques mencionados anteriormente con los bloques de llamada: procedures\_callreturn y procedures\_callnoreturn.

\textbf{Loops}: para puntuar el uso de bucles hay que localizar los bloques: controls\_while, controls\_forRange, controls\_forEach. Si solamente se utilizan while, tendrá puntuación 1. Si se utilizan forRange (con o sin bloques while), la puntuación será 2. Por último, si se encuentran forEach, obtendrá puntuación 3.

\textbf{Conditional}: a diferencia de la rúbrica de Code Master, los condicionales se evalúan comprobando el uso de if-then, if-then-else y de if-then-elseif. Para ello se buscan los bloques de tipo controls\_if y controls\_choose, este último contabiliza como if-then-else. Para los controls\_if, hay que tener en cuenta la etiqueta hija ``mutation'' donde podemos encontrar los atributos else o elseif. Si no encontramos ninguno de estos, contabiliza como un if-then. La puntuación es una suma: uso de if-then, uso de if-then-else y uso de if-then-elseif, donde cada uno suma uno.

\textbf{Math and Logic Operations}: el algoritmo tiene que hallar los bloques que contengan math o logic en su tipo. La puntuación depende de cuántos bloques de estos tipos se utilicen.

\textbf{Lists}: para la evaluación de este criterio se comprueba el número de listas creadas (bloque lists\_create\_with). Para conseguir la puntuación máxima, es necesario una lista de tuplas, lo que en AppInventor se traduce como una lista de listas o también el uso de lists\_lookup\_in\_pairs.

\textbf{Data Persistance}: la persistencia de datos se puntúa en función de dónde se guardan los datos. Si es en variables o componentes de la interfaz gráfica, no puntúa. Si se almacenan File o FusionTables, puntúan 1. Si los datos se guardan en TinyDB, 2. Por último, si se utilizan TinyWebDB o FirebaseDB se obtendrá una puntuación de 3. Todas estas formas de almacenamiento se localizan en el .scm como componentes.

\textbf{Sensors}: los sensores pueden ser: acelerómetro, lector de código de barras, reloj, giroscopio, sensor de localización, NFC, sensor de orientación, podómetro y sensor de proximidad. La puntuación depende del número de tipos de sensores diferentes que utilice la aplicación, siendo 0 no utilizar ningún sensor y 3 utilizar más de dos tipos.

\textbf{Media}: los componentes multimedia son los siguientes: grabación de vídeo, cámara, selector de imagen, reproductor de audio, grabadora, reconocimiento de voz, texto a voz, reproductor de vídeo y traductor Yandex. La puntuación es análoga a la puntuación los sensores.

\textbf{Social}: los componentes sociales son: selector de contacto, selector de e-mail, llamada, selector de número de teléfono, compartir, enviar mensaje, compartir vía Twitter. La puntuación es análoga a los dos puntos anteriores.

\textbf{Connectivity}: en este criterio se evalúa el uso de los componentes de conectividad. Si no se utiliza ninguno, la puntuación es 0. Si se utiliza el componente activity starter puntúa 1. Usar componentes bluetooth (tanto cliente como servidor) puntúa 2. Para obtener una puntuación de 3, se ha de usar el componente web.

\textbf{Drawing and Animation}: para evaluar los componentes de dibujo y animación se tiene en cuenta el uso de estos componentes: canvas (1 punto), bola (2 puntos) e imagen interactiva (3 puntos).

En la aplicación web, el usuario selecciona el proyecto que desea evaluar y lo sube. La aplicación realiza el análisis de los bloques y componentes siguiendo estos criterios y cuando se tienen todos puntuados, se muestra la página de resultados, similar a la de Dr. Scratch. Más adelante, en la Figura~\ref{figura:dr-ai-score} veremos la evaluación de un proyecto con nivel alto.

\section{Dr. AppInventor para múltiples proyectos}
\label{sec:dr-ai-multi}

Ya tenemos el algoritmo que extrae los bloques, los clasifica y devuelve una evaluación de un proyecto, ahora queremos que el algoritmo extraiga los bloques y realice la evaluación varios proyectos a la vez para posteriormente analizar los datos obtenidos.

\subsection{Recopilación de proyectos}
\label{subsec:projects}

Para obtener los proyectos hay que acceder a la galería de AppInventor (puede verse en la Figura~\ref{figura:gallery}) y seleccionar los proyectos deseados. En nuestro caso, tenemos 62 proyectos de la sección ``Popular'' y 1.160 de la sección ``Recent'', por orden de aparición. 

Para descargar los proyectos es necesario iniciar sesión con una cuenta de Gmail, acceder a la galería, copiar el proyecto al perfil propio y, por último, descargarlo. El proceso se trató de automatizar lo máximo posible, tanto como la web de AppInventor permitió. Con un script se copiaban los proyectos de la galería al perfil y, como no se pueden descargar todos los proyectos del perfil a la vez, empleamos otro script para descargarlos uno a uno.


\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/gallery}
  \caption{Galería de AppInventor.}
  \label{figura:gallery}
\end{figure}
\newpage
\subsection{Adaptación del algoritmo}

El nuevo algoritmo analiza cada uno de los proyectos obtenidos, situados en un mismo directorio, de la misma manera que antes, pero ahora se guardan las puntuaciones de los criterios y la puntuación total en forma de CSV (Figura~\ref{figura:csv-ct}).

\begin{figure}[!h]
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/csv-ct}
  \caption{CSV con las puntuaciones (results.csv).}
  \label{figura:csv-ct}
\end{figure}

Además, se crea un nuevo diccionario que tiene como clave los tipos de bloques que se emplean en el proyecto y el número de apariciones en los .bky como valor. Este diccionario se adapta para almacenarlo como otro CSV (Figura~\ref{figura:csv-blocks}) para el posterior análisis de ambos ficheros.

\begin{figure}[!h]
  \centering
  \includegraphics[width=14cm, keepaspectratio]{img/csv-blocks}
  \caption{CSV con los bloques (blocks.csv).}
  \label{figura:csv-blocks}
\end{figure}

\section{Interfaz de Dr. AppInventor}
\label{app:interfaz}

\subsection{Página de inicio}

La web que verá el usuario al entrar en Dr. AppInventor tiene el aspecto mostrado en la Figura~\ref{figura:dr-ai-home}. La apariencia es exactamente la de Dr. Scratch, utilizamos todas las secciones e imágenes cambiando Scratch por AppInventor. 

Para subir el proyecto que se desea analizar, a diferencia de Dr. Scratch, sólo se pueden subir archivos locales, ya que AppInventor no proporciona una URL desde la que descargar los proyectos. En el apartado de subida, pulsando la palabra ``proyecto'' de color rojo, aparece una imagen que muestra cómo el usuario puede descargar los proyectos de AppInventor a su ordenador. Esta imagen puede verse en la Figura~\ref{figura:dr-ai-help}

\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/dr-ai-home}
  \caption{Página de inicio de Dr. AppInventor.}
  \label{figura:dr-ai-home}
\end{figure}

\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/dr-ai-help}
  \caption{Ayuda para descargar un proyecto AppInventor.}
  \label{figura:dr-ai-help}
\end{figure}

\subsection{Página de resultados}
\label{app:interfaz-resultados}

En la Figura~\ref{figura:dr-ai-score} se muestra un ejemplo del interfaz web que el usuario ve una vez su proyecto ha sido analizado. Como mencionamos anteriormente, solo se implementa la evaluación de los criterios del pensamiento computacional. 

A la izquierda se puede ver en primer lugar la puntuación total y debajo las funcionalidades de Dr. Scratch que no se han implementado para este proyecto: ``Mejores prácticas'' que muestran los malos hábitos de programación en el proyecto y ``Certificado del proyecto'' donde se puede descargar un diploma con el resultado obtenido. 

A la derecha se muestran las puntuaciones de los criterios individualmente. Este ejemplo en concreto es el programa con mayor variedad de bloques, esto es muy importante para la puntuación final como veremos en el siguiente capítulo. Podemos ver que obtiene una calificación alta: 36/45. En más de la mitad de criterios consigue la puntuación máxima, 3 puntos. Cuatro de los criterios se califican con 2 puntos y únicamente hay un criterio con 1 punto y otro que no puntúa.

\begin{figure}[!h]
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/dr-ai-score}
  \caption{Página de resultados en Dr. AppInventor.}
  \label{figura:dr-ai-score}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}
\label{chap:results}

Con los ficheros generados en la última sección, ya tenemos los datos que vamos a tratar y analizar, para comprobar el estado actual de los proyectos desarrollados por la comunidad AppInventor. 

\section{Número de bloques}

En primer lugar, guardamos en una variable tipo DataFrame los datos de blocks.csv y utilizamos la función \emph{describe()} para obtener estadísticas descriptivas del número de bloques total en los proyectos como la media, el mínimo, el máximo o la mediana. Seguidamente se eliminan los proyectos vacíos, es decir, proyectos cuyo número de bloques es igual a cero y se vuelve a llamar a la función \emph{describe()}. Por último, se realiza el mismo proceso con los proyectos duplicados. Para eliminar los proyectos duplicados, pandas proporciona \emph{drop\_duplicates()}.

En la Tabla~\ref{tabla:proj-blocks} podemos visualizar las estadísticas de los tres estados comentados. Originalmente había 1.222 proyectos, tras la eliminación de proyectos vacíos hay 1.102 y al descontar los duplicados obtenemos la cifra final de 730 proyectos. Podemos ver que la media de bloques aumenta cuando descartamos proyectos no válidos. Lo mismo ocurre con las demás estadísticas, excepto el máximo que siempre es 5.476.

\begin{table}[!h]
 \begin{center}
 \begin{tabular}{ | l | r | r | r |} 
\hline
& Original & Sin vacíos & Sin duplicados \\ \hline
Proyectos & 1.222 & 1.102 & 730\\ \hline
Media & 187,89 & 208,35 & 211,48\\ \hline
Desviación típica & 463,68 & 483,90 & 502,62 \\ \hline
Mediana & 47 & 55 & 60\\ \hline
Mínimo & 0 & 1 & 1\\ \hline
Máximo & 5.476 & 5.476 & 5.476 \\ \hline
 \end{tabular}
 \caption{Estadísticas del número de bloques.}
 \label{tabla:proj-blocks}
 \end{center}
\end{table}

\section{Variedad en los proyectos}

Llamamos variedad al número de bloques de diferente tipo empleados en un proyecto. En el análisis, la variedad se cuenta como el número de columnas (que representan los tipos de bloques) con valor distinto de cero, para todas las filas (que representan los proyectos). La Figura~\ref{figura:variety} representa la distribución de la variedad en todos los proyectos, donde el eje X es la variedad y el eje Y, la frecuencia, o las veces que se da una variedad. Observamos que los valores predominantes de la variedad están entre 3 y 6, mientras que según aumenta de valor, disminuye la frecuencia de proyectos. La máxima variedad es 61 y solamente un proyecto la tiene.  

\begin{figure}[!h]
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/variety}
  \caption{Distribución de la variedad.}
  \label{figura:variety}
\end{figure}

\section{Uso de bloques}

En esta sección se estudia el uso de los distintos bloques en los proyectos, de este modo podremos conocer si existe alguno infrautilizado.

\subsection{Familias de bloques}

Inicialmente se analizan las familias, entendiendo por familias los 8 tipos de bloques mencionados en la sección~\ref{sec:ai} sumando una nueva familia formada por los bloques específicos de los componentes, que llamaremos Componentes. En la Tabla~\ref{tabla:fam-blocks} se pueden ver en orden de uso. En primer lugar con diferencia, encontramos Componentes que, al abarcar diferentes elementos (cada uno con sus bloques de métodos y eventos) es normal que predomine. Mientras que en último lugar encontramos la familia Colores, no es de extrañar ya que en comparación con Componentes su aplicación es mucho más reducida. Por otro lado, desde el punto de vista del pensamiento computacional, hay dos familias muy ligadas que no destacan: Control, relacionada con el pensamiento algorítmico y Procedimientos, relacionada con la abstracción. Estas familias ocupan el sexto y octavo lugar respectivamente, cuando deberían ser de las principales. Este es uno de los posibles aspectos a resaltar durante el aprendizaje de los usuarios.

\begin{table}[!h]
\begin{center}
\begin{tabular}{| l | r |}
\hline
\textbf{Familia} & \textbf{Frecuencia} \\ \hline
Componentes & 49.507 \\ \hline
Texto & 25.426\\ \hline
Matemáticas & 24.862\\ \hline
Variables & 21.765\\ \hline
Lógica & 12.792\\ \hline
Control & 8.915\\ \hline
Listas & 4.381\\ \hline
Procedimientos & 4.282\\ \hline
Colores & 2.452\\ \hline
Total & 154.382\\ \hline
 \end{tabular}
 \caption{Familias ordenadas por uso.}
 \label{tabla:fam-blocks}
 \end{center}
\end{table}

\subsection{Tipos de bloques}

Nos referimos con tipos de bloques a cada uno de los diferentes bloques que se pueden utilizar en AppInventor. Para esta sección, se realiza un sumatorio de los bloques utilizados en todos los proyectos, separados por tipo. En la Tabla~\ref{tabla:type-blocks} se muestran las estadísticas descriptivas del número de bloques que conforman los tipos. Vemos que hay 107 tipos diferentes en total con una media de aproximadamente 1.443 bloques. La desviación típica es mucho mayor que la media, lo que significa que existen valores extremos, es decir, hay grandes diferencias entre valores. Otra prueba de ello es la mediana, 133, que nos indica que, por lo menos, el 50\% de los proyectos tienen 133 bloques o menos, quedando muy lejos de la media. Esto nos indica que habrá una minoría de proyectos con valores muy elevados que alzarán la media, como puede se puede ver en el máximo: 28.927 bloques. 

\begin{table}[!h]
\begin{center}
\begin{tabular}{| l | r |}
\hline
Tipos & 107\\ \hline
Media & 1.442,82\\ \hline
Desviación típica & 4.232,51\\ \hline
Mediana & 133\\ \hline
Mínimo & 1\\ \hline
Máximo & 28.927\\ \hline
Total & 154.382\\ \hline
 \end{tabular}
 \caption{Estadísticas de los tipos de bloques.}
 \label{tabla:type-blocks}
 \end{center}
\end{table}

A continuación se analizan los bloques más y menos utilizados. Además de realizar este estudio para todos los proyectos, se estudia también el uso en proyectos con baja variedad. Decimos que un proyecto tiene baja variedad cuando contiene como máximo 10 bloques diferentes. Se elige esta cifra ya que, de este modo los proyectos con baja variedad y los de alta variedad se distribuirán al 50\%, como se puede ver en la Tabla~\ref{tabla:type-blocks}. 

Los resultados en la Tabla~\ref{tabla:use-blocks} muestran, fijándonos primero en todos los proyectos, que los dos bloques más utilizados son \emph{component\_set\_get}, cuya función es introducir u obtener las propiedades de un componente, y \emph{text} que se utiliza para crear strings. A continuación, está \emph{math\_number}, utilizado para representar números. En cuarto lugar, \emph{lexical\_variable\_get}, proporciona el valor de cualquier variable. Por último, \emph{component\_event} toma el valor de cualquier evento que pertenezca a un componente. Estos bloques representan un alto porcentaje de sus correspondientes familias: Componentes: 77,82\%; Texto: 89,06\%; Matemáticas: 61,57\%; Variables: 67,37\%. Mientras tanto, los bloques menos utilizados son aquellos con una función menos práctica desde el punto de vista de una aplicación móvil. Por ejemplo, \emph{math\_tan} que calcula la tangente dado un valor o \emph{text\_is\_string} que comprueba si una variable es un string.

Por otro lado, vemos que tres de los cinco primeros bloques en todos los proyectos aparecen también como los más utilizados en los proyectos con baja variedad. Los dos primeros coinciden, mientras que \emph{component\_event} ahora aparece el tercero. Los nuevos bloques son \emph{component\_method} con el que se llama a los métodos que pueda utilizar un componente, y \emph{controls\_openAnotherScreen} que abre una nueva pantalla con el nombre que se pase como argumento. Dentro de los bloques menos utilizados, descubrimos 42 que no se utilizan ni una sola vez. Se han seleccionado los cinco que aparecen en la tabla porque confirman la necesidad de insistir en las familias Control y Procedimientos a la hora de instruir. Estos bloques ya se habían mencionado en la sección~\ref{sec:score} como factores indispensables para puntuar en, al menos, tres criterios.

\begin{table}[!h]
\begin{center}
\begin{tabular}{| l | r | l | r |}
\hline
\multicolumn{2}{| c |}{\textbf{Todos los proyectos}}  & \multicolumn{2}{| c |}{\textbf{Proyectos baja variedad}} \\ \hline
component\_set\_get & 28.927 & component\_set\_get & 5.562 \\ \hline
text & 22.644 & text & 4.538 \\ \hline
math\_number & 15.308 & component\_event & 3.960 \\ \hline
lexical\_variable\_get & 14.662 & component\_method & 3.484 \\ \hline
component\_event & 9.599 & controls\_openAnotherScreen & 1.277 \\ \hline
... & ... & ... & ... \\ \hline
list\_to\_csv\_table & 3 & controls\_forEach & 0 \\ \hline
math\_tan & 2 & controls\_while & 0 \\ \hline
obfuscated\_text & 2 & controls\_choose & 0\\ \hline
text\_is\_string & 2 & procedures\_callreturn & 0\\ \hline
controls\_closeScreenWithPlainText & 1 & procedures\_defreturn & 0\\ \hline
 \end{tabular}
 \caption{Bloques más y menos utilizados.}
 \label{tabla:use-blocks}
 \end{center}
\end{table}

\section{Relación Puntuación/Variedad}

En esta sección pretendemos comprobar si es cierto lo que sugiere la intuición: a mayor variedad, mayor puntuación. La Tabla~\ref{tabla:var-score} muestra una comparación estadística de las puntuaciones de los proyectos con alta variedad frente a los proyectos con baja variedad. Los proyectos con más de 10 bloques diferentes representan el 48,2\% de los proyectos (352 de 730). A diferencia de las estadísticas anteriores, la media y la mediana apenas se diferencian, lo que significa que no habrá grandes saltos entre valores. Observando los datos obtenidos, las medias son 18,56 y 9,89, y los máximos, 36 y 19, respectivamente. Por lo tanto, se confirma la hipótesis inicial, ya que la variedad alta prácticamente duplica todos los valores de la baja.

\begin{table}[!h]
\begin{center}
\begin{tabular}{| l | r | r |}
\hline
& Alta variedad & Baja variedad \\ \hline
Proyectos & 352 & 378\\ \hline
Porcentaje & 48,2 & 51,8\\ \hline
Media & 18,56 & 9,89\\ \hline
Desviación típica & 5.33 & 3.27\\ \hline
Mediana & 18 & 10\\ \hline
Mínimo & 7 & 3\\ \hline
Máximo & 36 & 19\\ \hline
 \end{tabular}
 \caption{Puntuaciones con alta y baja variedad.}
 \label{tabla:var-score}
 \end{center}
\end{table}

\section{Variedad frente a cantidad}

Conociendo los resultados de la sección anterior, nos hacemos una idea de que es más importante un proyecto con alta variedad antes que un proyecto con muchos bloques de los mismos tipos. Para comprobar esto, se compara el proyecto que posee mayor número de bloques con el proyecto de mayor variedad. En la Tabla~\ref{tabla:var-quan} podemos ver que se cumple. El primer proyecto contiene 5.476 bloques pero solo 16 son diferentes, en consecuencia obtiene una puntuación de 18. Sin embargo, el proyecto con 4.115 bloques contiene 61 tipos distintos y su puntuación es mucho mayor, 36. 

\begin{table}[!h]
\begin{center}
\begin{tabular}{| r | r | r |}
\hline
Cantidad & Variedad & Puntuación \\ \hline
5.476 & 16 & 18\\ \hline
4.115 & 61 & 36\\ \hline
 \end{tabular}
 \caption{Comparación variedad frente cantidad.}
 \label{tabla:var-quan}
 \end{center}
\end{table}

Con estos resultados podemos concluir que la variedad es otro parámetro a tener en cuenta a la hora de buscar mejoras en los usuarios. Un mayor énfasis en la variedad puede llegar a multiplicar la puntuación por dos. Esto se debe principalmente a que los criterios de evaluación se basan, en su mayoría, en la aparición de diferentes bloques.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}

Este último capítulo es un análisis de los resultados conseguidos con este Trabajo Fin de Grado desde el punto de vista de los objetivos planteados pero también desde el punto de vista de los conocimientos aplicados y adquiridos. Por último, finaliza con el planteamiento de algunos futuros trabajos.

\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Repasando el capítulo~\ref{chap:objetivos}, el objetivo principal de este proyecto es crear una herramienta que analice el pensamiento computacional de proyectos AppInventor. Este objetivo sí se ha cumplido, hemos creado la aplicación web Dr. AppInventor, que sigue el diseño de Dr. Scratch con la rúbrica de Code Master y proporciona una evaluación de los proyectos AppInventor. \\

Por otro lado, a partir de esta herramienta pretendíamos buscar caminos de aprendizaje para guiar a los usuarios en el desarrollo de sus habilidades del pensamiento computacional. Esta búsqueda la realizamos mediante el análisis de varios proyectos de la galería de AppInventor. Este análisis nos ha proporcionado información sobre cómo los alumnos pueden mejorar, ya que hemos encontrado carencias en bloques directamente ligados a las habilidades. Además, hemos confirmado la importancia de la variedad de bloques dentro de un proyecto para conseguir un buen resultado. Podemos decir que esta información nos muestra al menos tres lecciones para los usuarios: bloques de Control, bloques de Procedimientos y variedad en los proyectos. Por lo tanto, el objetivo de localizar caminos de aprendizaje también se ha cumplido.

Los objetivos específicos, como ya se mencionó en su correspondiente capítulo, eran las tareas que hizo falta completar para conseguir el objetivo general. Por ello, afirmamos que se cumplieron. Sin embargo, la obtención de proyectos se vio limitada debido a problemas con la web de AppInventor. Como ya adelantamos en la sección~\ref{subsec:projects}, utilizamos dos scripts para automatizar la extracción de los proyectos, uno de copia al perfil y otro de descarga. El script de copia solo podia guardar en el perfil entre 30 y 40 bloques en una pasada, ya que, a partir de estas cifras, la web se bloqueaba y dejaba de responder. Algo similar ocurría con el script de descarga. Esto provocó un aumento del tiempo de descarga y, por lo tanto, una disminución del número de proyectos obtenidos.


\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Para realizar este trabajo, me han resultado indispensables todas las asignaturas que he tenido relacionadas con la programación. A continuación, se enumeran en orden cronológico.

\begin{enumerate}
  \item Informática I, con el lenguaje ``Picky", donde aprendí los fundamentos básicos de la programación y que los problemas se resuelven ``paso a paso".
  \item Informática II, con el lenguaje ADA. Mi primer contacto con la programación contrarreloj, me enseñó que no siempre voy a estar en un entorno cómodo y aún así voy a tener que desenvolverme.
  \item Protocolos para la Transmisión de Audio y Vídeo en Internet: aquí conocí Python, lenguaje que he necesitado para crear la aplicación web con Django y para el análisis de datos con pandas.
  \item Construcción de Servicios y Aplicaciones Audiovisuales en Internet, Gráficos y Visualización 3D y Laboratorio de Tecnologías Audiovisuales en la Web: estas asignaturas se complementaban entre sí, me enseñaron todo lo que sé de tecnologías web: JavaScript, HTML, CSS...
\end{enumerate}

Sería injusto por mi parte no mencionar las demás asignaturas ya que, de un modo u otro, todas ellas me han aportado algo, me han ayudado a plantear y resolver los problemas que se presenten. En definitiva, me han ayudado a ser ingeniero.

\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

En esta sección se explican los conocimientos que se han adquirido gracias al desarrollo de este trabajo:

\begin{enumerate}
  \item La herramienta Django de Python: para la implementación de la aplicación web. Además, me sirvió para adelantar trabajo ya que, en la asignatura Laboratorio de Tecnologías Audiovisuales en la Web del segundo cuatrimestre de este curso, fue parte del temario.
  \item La librería pandas también de Python, me permitió tomar contacto con el análisis de datos y de la cual todavía me queda mucho por descubrir.
  \item Dejando de lado la programación, he descubierto lo que es abarcar un proyecto real, donde no hay un guión a seguir como en las prácticas de la universidad.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

En esta sección se proponen sugerencias o ideas para futuros trabajos con intención de mejorar las habilidades del pensamiento computacional:

\begin{itemize}
  \item En primer lugar, incluir los caminos de mejora en la herramienta Dr. AppInventor.
  \item Proseguir con el análisis, añadiendo nuevos proyectos para obtener más información.
  \item Siguiendo las posibles mejoras propuestas en~\cite{robles2018ontools}, un posible trabajo futuro es mostrar a los aprendices ejemplos y proponer ejercicios para que practiquen. Los ejemplos y ejercicios propuestos deben incluir bloques de Control y/o Procedimientos, una variedad alta o la combinación de ambos. Otro posible paso sería proporcionar retroalimentación personalizada a cada usuario basada en sus progresos y necesidades. Para llevar esto a cabo, podría extrapolarse el análisis realizado en este trabajo a los proyectos de cada usuario en concreto.
  \item Otra medida que se propone en~\cite{robles2018ontools} es integrar las herramientas de análisis en sus entornos de desarrollo correspondientes, a raíz de esto puede surgir una nueva idea aunque más extrema: diseñar un nuevo entorno orientado especialmente al desarrollo del pensamiento computacional.
\end{itemize} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}

Este apéndice está dedicado a explicar cómo poner en marcha y utilizar la aplicación web Dr. AppInventor. Es necesario tener Python 2.7 y Django 1.8 para ejecutarlo.

Los archivos que necesita Dr. AppInventor se encuentran en un repositorio de Github\footnote{\url{https://github.com/robernom/dr-app-inventor}} y para obtenerlos se puede hacer de dos formas: clonar el repositorio o descargarlo como ZIP. Una vez se ha descargado todo, hay que seguir estos pasos:

\begin{enumerate}
  \item Abrir el terminal en el directorio donde se encuentre el código.
  \item Ejecutar el comando: \emph{python manage.py migrate}.
  \item Ejecutar el comando: \emph{python manage.py runserver}.
  \item Abrir en un navegador la siguiente URL: localhost:8000.
\end{enumerate}

En el navegador aparecerá la página de inicio, vista en la imagen~\ref{figura:dr-ai-home}. Para subir el proyecto que se desea analizar hay que pulsar en ``Elige Proyecto'' y seleccionar el archivo. El análisis comenzará tras hacer click en el botón ``ANALIZA MI PROYECTO'' y la aplicación pasará a la página con los resultados del proyecto, similar a la vista en la imagen~\ref{figura:dr-ai-score}

En un futuro, si la aplicación se ejecuta desde un servidor y se asigna a un dominio, los usuarios no tendrán que realizar estos pasos. Únicamente necesitarán acceder desde su navegador a la URL correspondiente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
